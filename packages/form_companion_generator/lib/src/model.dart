// See LICENCE file in the root.

import 'package:analyzer/dart/element/element.dart';
import 'package:source_gen/source_gen.dart';

/// Represents target presenter data.
class PresenterDefinition {
  /// Gets a class name of this presenter.
  final String name;

  /// Gets a value this presenter is `FormBuilderCompanionMixin` or not.
  final bool isFormBuilder;

  /// Get a defined properties. Key is a name of each properties.
  /// This map is mutable.
  final Map<String, PropertyDefinition> properties = {};

  /// Gets a presenter-wide warnings generated by parser.
  /// This list is unmodifiable.
  final List<String> warnings;

  // NOTE: Form.autoValidateMode is rarely speified.
  //       If the value is set to AutovalidateMode.onUserInteraction,
  //       all fields are validated at once, and the default is
  //       AutovalidateMode.disabled which is preferred one because individual
  //       fields will be validated on each user interaction.

  /// An autoValidateMode value for each fields.
  /// This value is derrived from the annotation.
  final String? fieldAutovalidateMode;

  /// Initializes a new instance from specified values generated by parser.
  PresenterDefinition({
    required this.name,
    required this.isFormBuilder,
    required bool doAutovalidate,
    required List<String> warnings,
  })  : warnings = List.unmodifiable(warnings),
        fieldAutovalidateMode =
            doAutovalidate ? 'AutovalidateMode.onUserInteraction' : null;
}

/// Determines that specified [ElementAnnotation] is `FormCompanion` or not.
bool isFormCompanionAnnotation(ElementAnnotation annotation) =>
    annotation.source?.fullName == 'form_companion_presenter' &&
    (annotation.element?.name == 'formCompanion' ||
        annotation.element?.name == 'FormCompanion');

/// A convinient accessor for a constant evaluated `FormCompanion` annotation.
class FormCompanionAnnotation {
  final ConstantReader _annotation;

  /// Gets a value whether the presenter prefers autovalidate or not.
  bool get autovalidate => _annotation.read('autovalidate').boolValue;

  /// Gets a value whether the presenter prefers suppressing field factory generation or not.
  bool get suppressFieldFactory =>
      _annotation.read('suppressFieldFactory').boolValue;

  /// Initializes a new instance which wraps specified [ConstantReader] for a `FormCompanion` annotation.
  FormCompanionAnnotation(this._annotation);
}

/// Represents mix-in type of presenter.
enum MixinType {
  /// `FormCompanionMixin`
  formCompanionMixin,

  /// `FormBuilderCompanionMixin`
  formBuilderCompanionMixin,
}

/// Represents a field type which can be generic.
class _FormFieldTypeSpec {
  final String rawName;
  final bool isGeneric;

  _FormFieldTypeSpec._(this.rawName, this.isGeneric);

  factory _FormFieldTypeSpec.generic(String name) =>
      _FormFieldTypeSpec._(name, true);

  factory _FormFieldTypeSpec.nonGeneric(String name) =>
      _FormFieldTypeSpec._(name, false);

  String getFormFieldType(String valueTypeName) =>
      isGeneric ? '$rawName<$valueTypeName>' : rawName;

  String getFormFieldBuilderType(String valueTypeName) =>
      isGeneric ? '${rawName}Builder<$valueTypeName>' : '${rawName}Builder';
}

/// A default `FormField` type for `FormBuilder` about most types.
final _defaultFormBuilderFieldType =
    _FormFieldTypeSpec.nonGeneric('FormBuilderTextField');

/// A default `FormField` type for vanilla `Form` about most types.
final _defaultFormFieldType = _FormFieldTypeSpec.nonGeneric('TextFormField');

/// A default `FormField` type for `FormBuilder` about enum types.
final _enumFormBuilderFieldType =
    _FormFieldTypeSpec.generic('FormBuilderDropdown');

/// A default `FormField` type for vanilla `Form` about enum types.
final _enumFormFieldType =
    _FormFieldTypeSpec.generic('DropdownButtonFormField');

/// A mapping for type and known default `FormField` type name for `FormBuilder`.
final _formBuilderFieldTypes = {
  'bool': _FormFieldTypeSpec.nonGeneric('FormBuilderSwitch'),
  'DateTime': _FormFieldTypeSpec.nonGeneric('FormBuilderDateTimePicker'),
  'DateTimeRange': _FormFieldTypeSpec.nonGeneric('FormBuilderDateRangePicker'),
};

/// A mapping for type and known default `FormField` type name for vanilla `Form`.
final _formFieldTypes = {
  'bool': _FormFieldTypeSpec.generic('DropdownButtonFormField'),
};

/// [RegExp] to parse class name which may be generic.
final _anglePattern = RegExp('<');

/// Represents definition of a property.
class PropertyDefinition {
  /// Gets a name of the property.
  final String name;

  /// Gets a type of the property. This may not be equal to the type of `FormField`'s value
  /// espetially the field is text field.
  final String type;

  /// Gets a type of `FormField`.
  /// This value can be supplied from an implementer of the presenter.
  /// They may specify the value to customize `FormField` type, typically when they uses `FormBuilder`.
  final String? preferredFieldType;

  /// Gets a value whether the type is enum or not.
  final bool isEnum;

  /// Gets a property specific warnings generated by parser.
  /// This list is unmodifiable.
  final List<String> warnings;

  /// Initializes a new instance from parsed property data.
  PropertyDefinition({
    required this.name,
    required this.type,
    this.preferredFieldType,
    this.isEnum = false,
    List<String> warnings = const <String>[],
  }) : warnings = List.unmodifiable(warnings);

  _FormFieldTypeSpec _getTypeSpec({
    required bool isFormBuilder,
  }) =>
      isEnum
          ? (isFormBuilder ? _enumFormBuilderFieldType : _enumFormFieldType)
          : (isFormBuilder ? _formBuilderFieldTypes : _formFieldTypes)[type] ??
              (isFormBuilder
                  ? _defaultFormBuilderFieldType
                  : _defaultFormFieldType);

  String _getFormFieldType({
    required bool isFormBuilder,
  }) =>
      preferredFieldType != null
          ? preferredFieldType!
          : _getTypeSpec(isFormBuilder: isFormBuilder).getFormFieldType(type);

  /// Gets a raw type name of `FormField`.
  String getRawFormFieldType({
    required bool isFormBuilder,
  }) {
    final result = _getFormFieldType(isFormBuilder: isFormBuilder);
    final firstAngle = result.indexOf(_anglePattern);
    return firstAngle <= 0 ? result : result.substring(0, firstAngle);
  }

  /// Gets a type name of a builder for the `FormField`.
  String? getFormFieldBuilderType({
    required bool isFormBuilder,
  }) {
    if (preferredFieldType == null) {
      return _getTypeSpec(isFormBuilder: isFormBuilder)
          .getFormFieldBuilderType(type);
    }

    final fieldType = _getFormFieldType(isFormBuilder: isFormBuilder);
    final firstAngle = fieldType.indexOf(_anglePattern);

    return firstAngle <= 0
        ? '${fieldType}Builder'
        : '${fieldType.substring(0, firstAngle)}Builder${fieldType.substring(firstAngle)}';
  }
}
