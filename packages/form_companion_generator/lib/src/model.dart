// See LICENCE file in the root.

import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:meta/meta.dart';
import 'package:source_gen/source_gen.dart';

import 'dependency.dart';
import 'type_instantiation.dart';

/// Represents target presenter data.
class PresenterDefinition {
  /// A class name of this presenter.
  final String name;

  /// A value this presenter is `FormBuilderCompanionMixin` or not.
  final bool isFormBuilder;

  /// A defined properties and their `FormField`s information.
  /// Key is a name of each properties.
  /// This map is mutable.
  final Map<String, PropertyAndFormFieldDefinition> properties;

  /// A unordered list of [LibraryImport] which represents prefixed library
  /// imports and restricted library imports.
  final List<LibraryImport> imports;

  /// Gets a presenter-wide warnings generated by parser.
  /// This list is unmodifiable.
  final List<String> warnings;

  // NOTE: Form.autoValidateMode is rarely speified.
  //       If the value is set to AutovalidateMode.onUserInteraction,
  //       all fields are validated at once, and the default is
  //       AutovalidateMode.disabled which is preferred one because individual
  //       fields will be validated on each user interaction.

  /// An autoValidateMode value for each fields.
  /// This value is derrived from the annotation.
  final String? fieldAutovalidateMode;

  /// Initializes a new instance from specified values generated by parser.
  PresenterDefinition({
    required this.name,
    required this.isFormBuilder,
    required bool doAutovalidate,
    required List<String> warnings,
    required this.imports,
    required Map<String, PropertyAndFormFieldDefinition> properties,
  })  : warnings = List.unmodifiable(warnings),
        properties = Map.unmodifiable(properties),
        fieldAutovalidateMode =
            doAutovalidate ? 'AutovalidateMode.onUserInteraction' : null;
}

final _annotationLibraryUri = Uri(
  scheme: 'package',
  path: 'form_companion_presenter/src/form_companion_annotation.dart',
);

/// Determines that specified [ElementAnnotation] is `FormCompanion` or not.
bool isFormCompanionAnnotation(ElementAnnotation annotation) =>
    annotation.element?.source?.uri == _annotationLibraryUri &&
    (annotation.element?.name == 'formCompanion' ||
        annotation.element?.name == 'FormCompanion');

/// A convinient accessor for a constant evaluated `FormCompanion` annotation.
@sealed
class FormCompanionAnnotation {
  final ConstantReader _annotation;

  /// Whether the presenter prefers autovalidate or not.
  bool get autovalidate => _annotation.read('autovalidate').boolValue;

  /// Whether the presenter prefers suppressing field factory generation or not.
  bool get suppressFieldFactory =>
      _annotation.read('suppressFieldFactory').boolValue;

  /// Initializes a new instance which wraps specified [ConstantReader] for a `FormCompanion` annotation.
  FormCompanionAnnotation(this._annotation);
}

/// Represents mix-in type of presenter.
enum MixinType {
  /// `FormCompanionMixin`
  formCompanionMixin,

  /// `FormBuilderCompanionMixin`
  formBuilderCompanionMixin,
}

/// Represents definition of a property.
@sealed
class PropertyDefinition {
  /// A name of the property.
  final String name;

  /// A type of the property. This may not be equal to the type of `FormField`'s value
  /// espetially the field is text field.
  final InterfaceType type;

  /// Preferred type name of `FormField`, which is specified as [Symbol] via
  /// `@FormCompanion` annotation.
  ///
  /// This type name should not have type paramters nor type arguments.
  final String? preferredFieldType;

  /// Gets a property specific warnings generated by parser.
  final List<String> warnings;

  /// Initializes a new instance from parsed property data.
  PropertyDefinition({
    required this.name,
    required this.type,
    required this.preferredFieldType,
    required this.warnings,
  });
}

/// A property definition with resolved `FormField` information.
@sealed
class PropertyAndFormFieldDefinition {
  final PropertyDefinition _property;

  /// A name of the property.
  String get name => _property.name;

  /// A type of the property. This may not be equal to the type of `FormField`'s value
  /// espetially the field is text field.
  DartType get type => _property.type;

  /// A type name of `FormField`.
  /// Note that this field should not include generic type parameters.
  ///
  /// This field is intended for error reporting.
  final String fieldTypeName;

  /// A type of `FormField`.
  ///
  /// This property will be `null` when failed to find target `FormField`.
  final InterfaceType? fieldType;

  /// A [ConstructorElement] of [fieldType] constructor to be called.
  ///
  /// This property will be `null` when failed to determine target `FormField`
  /// constructor, or [fieldType] is `null`.
  final ConstructorDeclaration? fieldConstructor;

  /// Property specific warnings generated by parser.
  List<String> get warnings => _property.warnings;

  /// A [TypeInstantiationContext] for [fieldType] constructor.
  ///
  /// This property will be `null` when failed to determine target `FormField`
  /// constructor, [fieldType] is `null`, or failed to resolve their dependency.
  final TypeInstantiationContext? instantiationContext;

  /// Initializes a new [PropertyAndFormFieldDefinition] instance.
  PropertyAndFormFieldDefinition({
    required PropertyDefinition property,
    required this.fieldType,
    required this.fieldTypeName,
    required this.fieldConstructor,
    required this.instantiationContext,
  }) : _property = property;
}
