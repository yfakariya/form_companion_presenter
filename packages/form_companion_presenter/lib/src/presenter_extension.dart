// See LICENCE file in the root.
// Rationale: This library is actually 'protected` member of the presenter
//            to keep API backword compability for derived types.
// ignore_for_file: invalid_use_of_visible_for_testing_member, invalid_use_of_visible_for_overriding_member, invalid_use_of_protected_member

import 'package:flutter/widgets.dart';

import 'form_companion_mixin.dart';
import 'value_converter.dart';

/// Provides convinient members to access properties.
extension CompanionPresenterMixinPropertiesExtension
    on CompanionPresenterMixin {
  /// Gets a [PropertyDescriptor] for the specified [name],
  /// which was registered via constrcutor.
  ///
  /// This method throws [ArgumentError] if the property named [name] does not
  /// exist, and throws [StateError] if [P] or [F] is not compatible with
  /// the `P` or `F` of getting [PropertyDescriptor].
  ///
  /// It is recommended to use type property accessors which are generated by
  /// `form_companion_generator` tool instead of using this method. It helps to
  /// avoid name and type arguments mismatch, and provides developer tools'
  /// input auto completion friendly syntax.
  PropertyDescriptor<P, F> getProperty<P extends Object, F extends Object>(
    String name,
  ) {
    final property = getPropertyInternal(name);

    if (property is! PropertyDescriptor<P, F>) {
      throw StateError(
        'A type of \'$name\' property is ${property.runtimeType} instead of PropertyDescriptor<$P, $F>.',
      );
    }

    return property;
  }

  /// Gets a saved property value of specified name.
  ///
  /// The value should be set from `FormField` via [savePropertyValue].
  /// This getter should be called in [doSubmit] implementation to get saved
  /// valid values.
  /// In addition, the value will be converted via [ValueConverter.toPropertyValue].
  ///
  /// It is recommended to use type property accessors which are generated by
  /// `form_companion_generator` tool, and then call [PropertyDescriptor.value]
  ///  on it, rather than using this method. It helps to
  /// avoid name and type arguments mismatch, and provides developer tools'
  /// input auto completion friendly syntax.
  ///
  /// It is also recommended to use form field factories which are generated by
  /// `form_companion_generator` tool instead of using this method. It provides
  /// boilerplates between [PropertyDescriptor] and [FormField] binding
  /// including [FormField.initialValue] setting with
  /// [PropertyDescriptor.value] value, [FormField.onSaved] handling with
  /// calling [PropertyDescriptor.setFieldValue], and [FormField.validator]
  /// settings with [PropertyDescriptor.getValidator].
  P? getSavedPropertyValue<P extends Object>(String name) =>
      getPropertyInternal(name).value as P?;

  /// Gets a setter to set a proprty value with validated form field input.
  ///
  /// The result should be bound to [FormField.onSaved] for vanilla [Form].
  ///
  /// It is recommended to use form field factories which are generated by
  /// `form_companion_generator` tool instead of using this method. It provides
  /// boilerplates between [PropertyDescriptor] and [FormField] binding
  /// including [FormField.initialValue] setting with
  /// [PropertyDescriptor.value] value, [FormField.onSaved] handling with
  /// calling [PropertyDescriptor.setFieldValue], and [FormField.validator]
  /// settings with [PropertyDescriptor.getValidator].
  void Function(dynamic) savePropertyValue(String name, BuildContext context) =>
      (dynamic v) =>
          getPropertyInternal(name).setFieldValue(v, getLocale(context));

  /// Gets a validator to validate form field input.
  ///
  /// The result should be bound to [FormField.validator].
  ///
  /// It is recommended to use form field factories which are generated by
  /// `form_companion_generator` tool instead of using this method. It provides
  /// boilerplates between [PropertyDescriptor] and [FormField] binding
  /// including [FormField.initialValue] setting with
  /// [PropertyDescriptor.value] value, [FormField.onSaved] handling with
  /// calling [PropertyDescriptor.setFieldValue], and [FormField.validator]
  /// settings with [PropertyDescriptor.getValidator].
  FormFieldValidator<F> getPropertyValidator<F extends Object>(
    String name,
    BuildContext context,
  ) =>
      (getPropertyInternal(name) as PropertyDescriptor<Object, F>)
          .getValidator(context);

  /// Gets a value which indicates that specified property has pencing
  /// asynchronous validation or not.
  ///
  /// Note that pending validation complection causes re-evaluation of validity
  /// of the form field, so rebuild will be caused from the field.
  ///
  /// It is recommended to use type property accessors which are generated by
  /// `form_companion_generator` tool instead of using this method. It helps to
  /// avoid name and type arguments mismatch, and provides developer tools'
  /// input auto completion friendly syntax.
  bool hasPendingAsyncValidations(String name) =>
      getPropertyInternal(name).hasPendingAsyncValidations;
}
